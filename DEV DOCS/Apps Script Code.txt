// Apps Script Code (single file: Code.gs)
/************************************************************
 * Cryo Calculator - Google Sheets Backend (Apps Script)
 * Endpoints:
 *   GET  ?action=ping
 *   POST { action:"login", email, password }
 *   POST { action:"save", type:"calc|split|reserve", token, record:{} }
 *   POST { action:"fetch", type:"calc|split|reserve|all", token, limit }
 *
 * Deployment:
 *   Deploy as Web App:
 *     - Execute as: Me
 *     - Who has access: Anyone with the link
 ************************************************************/

/** ====== CONFIG ====== **/
const CONFIG = {
  // If this script is bound to the spreadsheet, you can leave SHEET_ID blank.
  SHEET_ID: "",

  // REQUIRED: change this to a long random string.
  TOKEN_SECRET: "mySecretKey_2024_xyz789abc123def456ghi789jkl012mno345pqr678stu901vwx234",

  // Session duration
  TOKEN_TTL_SECONDS: 60 * 60 * 24 * 7, // 7 days

  // Sheet names
  SHEETS: {
    USERS: "users",
    CALC: "calc_records",
    SPLIT: "split_records",
    RESERVE: "reserve_records",
    AUDIT: "audit_log" // optional
  }
};
/** ====== CORS-Headers ====== **/
// Handle OPTIONS preflight requests for CORS
function doOptions(e) {
  return ContentService
    .createTextOutput("")
    .setMimeType(ContentService.MimeType.TEXT);
}

/** ====== ROUTING ====== **/
function doGet(e) {
  const action = (e && e.parameter && e.parameter.action) ? e.parameter.action : "ping";
  try {
    if (action === "ping") {
      return jsonResponse({ ok: true, service: "cryo-sheets-api", time: new Date().toISOString() });
    }
    return jsonResponse({ ok: false, error: "Invalid GET action" }, 400);
  } catch (err) {
    return jsonResponse({ ok: false, error: String(err) }, 500);
  }
}

function doPost(e) {
  try {
    const body = parseJsonBody_(e);
    const action = body.action;

    if (!action) return jsonResponse({ ok: false, error: "Missing action" }, 400);

    switch (action) {
      case "login":
        return handleLogin_(body);

      case "save":
        return handleSave_(body);

      case "fetch":
        return handleFetch_(body);

      default:
        return jsonResponse({ ok: false, error: "Invalid action" }, 400);
    }
  } catch (err) {
    // Log server-side only
    safeAudit_("ERROR", { message: String(err), stack: (err && err.stack) ? err.stack : "" });
    return jsonResponse({ ok: false, error: "Server error" }, 500);
  }
}

/** ====== LOGIN ====== **/
function handleLogin_(body) {
  const email = String(body.email || "").trim().toLowerCase();
  const password = String(body.password || "");

  if (!email || !password) {
    return jsonResponse({ ok: false, error: "Email and password required" }, 400);
    }

  const ss = getSpreadsheet_();
  const usersSheet = ss.getSheetByName(CONFIG.SHEETS.USERS);
  if (!usersSheet) return jsonResponse({ ok: false, error: "Missing users sheet" }, 500);

  const { headerMap, rows } = readSheetAsObjects_(usersSheet);
  // Expected columns: user_id, email, password_hash, role, active, created_at
  const user = rows.find(r => String(r.email || "").trim().toLowerCase() === email);

  if (!user) {
    safeAudit_("LOGIN_FAIL", { email, reason: "no_user" });
    return jsonResponse({ ok: false, error: "Invalid credentials" }, 401);
  }

  const active = String(user.active || "").toLowerCase();
  if (active === "false" || active === "0" || active === "no") {
    safeAudit_("LOGIN_FAIL", { email, reason: "inactive" });
    return jsonResponse({ ok: false, error: "Account disabled" }, 403);
  }

  const passwordHash = sha256Base64_(password);
  if (String(user.password_hash || "") !== passwordHash) {
    safeAudit_("LOGIN_FAIL", { email, reason: "bad_password" });
    return jsonResponse({ ok: false, error: "Invalid credentials" }, 401);
  }

  const userId = String(user.user_id || "").trim() || Utilities.getUuid();
  const role = String(user.role || "user").trim() || "user";
  const now = Math.floor(Date.now() / 1000);
  const exp = now + CONFIG.TOKEN_TTL_SECONDS;

  const token = signToken_({
    user_id: userId,
    email,
    role,
    iat: now,
    exp
  });

  safeAudit_("LOGIN_OK", { email, user_id: userId, role });

  return jsonResponse({
    ok: true,
    auth: { user_id: userId, email, role, token, exp }
  });
}

/** ====== SAVE RECORDS ====== **/
function handleSave_(body) {
  const token = String(body.token || "");
  const type = String(body.type || "").trim().toLowerCase();
  const record = body.record || null;

  if (!token) return jsonResponse({ ok: false, error: "Missing token" }, 401);
  if (!record) return jsonResponse({ ok: false, error: "Missing record" }, 400);
  if (!["calc", "split", "reserve"].includes(type)) {
    return jsonResponse({ ok: false, error: "Invalid record type" }, 400);
  }

  const auth = verifyToken_(token);
  if (!auth.ok) return jsonResponse({ ok: false, error: auth.error }, 401);

  const ss = getSpreadsheet_();
  const sheetName =
    type === "calc" ? CONFIG.SHEETS.CALC :
    type === "split" ? CONFIG.SHEETS.SPLIT :
    CONFIG.SHEETS.RESERVE;

  const sheet = ss.getSheetByName(sheetName);
  if (!sheet) return jsonResponse({ ok: false, error: `Missing sheet: ${sheetName}` }, 500);

  // Ensure required metadata exists
  const rowObj = Object.assign({}, record, {
    record_id: Utilities.getUuid(),
    user_id: auth.payload.user_id,
    timestamp: record.timestamp || new Date().toISOString(),
    source: record.source || "sync"
  });

  // Append row by header order
  appendObjectToSheet_(sheet, rowObj);

  safeAudit_("SAVE_OK", { type, user_id: auth.payload.user_id });

  return jsonResponse({ ok: true });
}

/** ====== FETCH RECORDS ====== **/
function handleFetch_(body) {
  const token = String(body.token || "");
  const type = String(body.type || "all").trim().toLowerCase();
  const limit = clampInt_(body.limit, 1, 500, 100);

  if (!token) return jsonResponse({ ok: false, error: "Missing token" }, 401);

  const auth = verifyToken_(token);
  if (!auth.ok) return jsonResponse({ ok: false, error: auth.error }, 401);

  const ss = getSpreadsheet_();
  const userId = auth.payload.user_id;

  const typesToFetch = (type === "all")
    ? ["calc", "split", "reserve"]
    : [type];

  const result = {};

  typesToFetch.forEach(t => {
    if (!["calc", "split", "reserve"].includes(t)) return;

    const sheetName =
      t === "calc" ? CONFIG.SHEETS.CALC :
      t === "split" ? CONFIG.SHEETS.SPLIT :
      CONFIG.SHEETS.RESERVE;

    const sheet = ss.getSheetByName(sheetName);
    if (!sheet) {
      result[t] = { ok: false, error: `Missing sheet: ${sheetName}`, records: [] };
      return;
    }

    const { rows } = readSheetAsObjects_(sheet);
    // Filter by user_id
    const mine = rows
      .filter(r => String(r.user_id || "") === userId)
      // Newest first if timestamp exists
      .sort((a, b) => String(b.timestamp || "").localeCompare(String(a.timestamp || "")))
      .slice(0, limit);

    result[t] = { ok: true, records: mine };
  });

  safeAudit_("FETCH_OK", { type, user_id: userId, limit });

  return jsonResponse({ ok: true, data: result });
}

/** ====== HELPERS: SHEET IO ====== **/
function getSpreadsheet_() {
  if (CONFIG.SHEET_ID && String(CONFIG.SHEET_ID).trim()) {
    return SpreadsheetApp.openById(CONFIG.SHEET_ID);
  }
  return SpreadsheetApp.getActiveSpreadsheet();
}

function readSheetAsObjects_(sheet) {
  const values = sheet.getDataRange().getValues();
  if (!values || values.length < 1) return { headerMap: {}, rows: [] };

  const headers = values[0].map(h => String(h).trim());
  const headerMap = {};
  headers.forEach((h, i) => { headerMap[h] = i; });

  const rows = [];
  for (let r = 1; r < values.length; r++) {
    const row = values[r];
    if (row.join("").trim() === "") continue;
    const obj = {};
    headers.forEach((h, i) => { obj[h] = row[i]; });
    rows.push(obj);
  }
  return { headerMap, rows };
}

/**
 * Appends an object to a sheet using the sheet's header row.
 * Any missing fields become blank. Extra fields are ignored unless the header includes them.
 */
function appendObjectToSheet_(sheet, obj) {
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0]
    .map(h => String(h).trim());

  // If sheet has no headers, fail loudly
  if (!headers.length || !headers[0]) {
    throw new Error(`Sheet "${sheet.getName()}" must have a header row (row 1).`);
  }

  const row = headers.map(h => (obj[h] !== undefined ? obj[h] : ""));
  sheet.appendRow(row);
}

/** ====== HELPERS: TOKEN (HMAC SIGNED) ====== **/
function signToken_(payload) {
  const header = { alg: "HS256", typ: "JWT-LITE" };
  const headerB64 = base64Url_(JSON.stringify(header));
  const payloadB64 = base64Url_(JSON.stringify(payload));
  const data = `${headerB64}.${payloadB64}`;
  const sig = hmacSha256Base64Url_(data, CONFIG.TOKEN_SECRET);
  return `${data}.${sig}`;
}

function verifyToken_(token) {
  try {
    const parts = String(token).split(".");
    if (parts.length !== 3) return { ok: false, error: "Bad token format" };

    const [hB64, pB64, sig] = parts;
    const data = `${hB64}.${pB64}`;
    const expectedSig = hmacSha256Base64Url_(data, CONFIG.TOKEN_SECRET);
    if (sig !== expectedSig) return { ok: false, error: "Invalid token signature" };

    const payloadJson = Utilities.newBlob(Utilities.base64DecodeWebSafe(pB64)).getDataAsString();
    const payload = JSON.parse(payloadJson);

    const now = Math.floor(Date.now() / 1000);
    if (payload.exp && now > payload.exp) return { ok: false, error: "Token expired" };

    return { ok: true, payload };
  } catch (err) {
    return { ok: false, error: "Token verify failed" };
  }
}

/** ====== HELPERS: HASHING / BASE64URL ====== **/
function sha256Base64_(text) {
  const bytes = Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, text, Utilities.Charset.UTF_8);
  return Utilities.base64Encode(bytes);
}

function hmacSha256Base64Url_(data, secret) {
  const sigBytes = Utilities.computeHmacSha256Signature(data, secret, Utilities.Charset.UTF_8);
  return Utilities.base64EncodeWebSafe(sigBytes).replace(/=+$/g, "");
}

function base64Url_(str) {
  return Utilities.base64EncodeWebSafe(str, Utilities.Charset.UTF_8).replace(/=+$/g, "");
}

/** ====== HELPERS: REQUEST / RESPONSE ====== **/
function parseJsonBody_(e) {
  if (!e || !e.postData || !e.postData.contents) return {};
  return JSON.parse(e.postData.contents);
}

/**
 * Returns a JSON response
 * Note: Apps Script doesn't support setHeader() on ContentService
 * CORS is handled automatically when deployed as Web App with "Anyone with the link" access
 */
function jsonResponse(obj, httpStatus) {
  const payload = Object.assign({}, obj, { status: httpStatus || 200 });

  return ContentService
    .createTextOutput(JSON.stringify(payload))
    .setMimeType(ContentService.MimeType.JSON);
}

function clampInt_(val, min, max, def) {
  const n = parseInt(val, 10);
  if (isNaN(n)) return def;
  return Math.max(min, Math.min(max, n));
}

/** ====== AUDIT LOG (OPTIONAL) ====== **/
function safeAudit_(eventType, data) {
  try {
    const ss = getSpreadsheet_();
    const sheet = ss.getSheetByName(CONFIG.SHEETS.AUDIT);
    if (!sheet) return; // optional
    const row = [
      new Date().toISOString(),
      String(eventType || ""),
      JSON.stringify(data || {})
    ];
    sheet.appendRow(row);
  } catch (e) {
    // Never block main flow due to audit failures
  }
}

/** ====== ADMIN: CREATE USER (RUN MANUALLY IN SCRIPT EDITOR) ====== **/
function adminCreateUser(email, password, role) {
  const ss = getSpreadsheet_();
  const sheet = ss.getSheetByName(CONFIG.SHEETS.USERS);
  if (!sheet) throw new Error("Missing users sheet");

  const cleanEmail = String(email || "").trim().toLowerCase();
  if (!cleanEmail) throw new Error("Email required");

  const userId = Utilities.getUuid();
  const hash = sha256Base64_(String(password || ""));
  const userRole = String(role || "user");

  // Ensure users sheet has headers matching:
  // user_id, email, password_hash, role, active, created_at
  appendObjectToSheet_(sheet, {
    user_id: userId,
    email: cleanEmail,
    password_hash: hash,
    role: userRole,
    active: true,
    created_at: new Date().toISOString()
  });

  return { user_id: userId, email: cleanEmail, role: userRole };
}

function createTestUser() {
  const result = adminCreateUser("test@example.com", "123456", "user");
  Logger.log(result);
}

function createAnotherUser() {
  const result = adminCreateUser("driver@company.com", "password123", "user");
  Logger.log(result);
}

// Required Sheet Headers (Row 1)

// Make sure each sheet has headers in row 1 (exact spelling matters).

// users
// user_id | email | password_hash | role | active | created_at

// calc_records

// Example minimal headers (add more columns if you want):

// record_id | user_id | timestamp | tank_type | full_inches | start_inches | end_inches | capacity | capacity_unit | gas | flow_value | timer_elapsed | result_text | source

// split_records
// record_id | user_id | timestamp | source_tank | destination | amount_scf | gas | notes | result_text | source

// reserve_records
// record_id | user_id | timestamp | reserve_amount | gas | remaining | warning_flag | result_text | source

// audit_log (optional)
// timestamp | event_type | data_json

// Deployment Steps (Literal)

// Open Google Sheet → Extensions → Apps Script

// Paste the code above into Code.gs

// Update:

// CONFIG.TOKEN_SECRET (must change)

// CONFIG.SHEET_ID (optional; blank is fine if bound to the sheet)

// Click Deploy → New deployment

// Select Web app

// Set:

// Execute as: Me

// Who has access: Anyone with the link

// Copy the Web App URL → this is what the client app will fetch().
// 

